# LOG DI SVILUPPO - FAVELLA 1 (Sessione 0.0.9)

## OBIETTIVO: Implementazione della Logica Condizionale e Puzzle Complessi

Questa sessione rappresenta un salto qualitativo fondamentale per FAVELLA 1: l'introduzione della **logica condizionale** nelle regole. Il motore di gioco ora può "ragionare" sullo stato del mondo e dell'inventario del giocatore, permettendo la creazione di puzzle complessi come la classica meccanica "chiave-serratura".

---

## FASE 1: Nuova Grammatica (v0.8) - Regole Condizionali

1.  **Sintassi per Regole Condizionali:**
    *   **Formato Base:** `Invece di [AZIONE] [OGGETTO] se [CONDIZIONE]: dire "[MESSAGGIO]".`
    *   **Scopo:** Eseguire una regola solo quando una specifica condizione è soddisfatta.

2.  **Tipi di Condizione Supportati (v0.1):**
    *   **Possesso del Giocatore:** `se il giocatore ha [NOME OGGETTO]`
        - Esempio: `Invece di aprire la porta se il giocatore ha la chiave: dire "La porta si apre!".`
    *   **Stato di un Oggetto (Proprietà):** `se [NOME OGGETTO] è [PROPRIETÀ]`
        - Esempio: `Invece di esaminare la porta se la porta è chiusa: dire "È chiusa a chiave.".`

---

## FASE 2: Evoluzione Architetturale di `strutture.py`

1.  **Nuova Gerarchia delle Condizioni:**
    *   Introdotta la classe base astratta [`Condizione`](strutture.py:10) con metodo `valuta(mondo) -> bool`
    *   Implementata [`CondizionePossesso`](strutture.py:15) per verificare se il giocatore possiede un oggetto
    *   Implementata [`CondizioneProprieta`](strutture.py:23) per verificare se un oggetto ha una specifica proprietà

2.  **Modifica della Classe `Regola`:**
    *   Aggiunto parametro opzionale [`condizione: Optional[Condizione]`](strutture.py:46)
    *   Le regole possono ora essere condizionali o incondizionate
    *   Retrocompatibilità garantita: le regole senza condizione funzionano come prima

3.  **Aggiornamento Versione:**
    *   Strutture dati aggiornate alla v0.8
    *   Report di compilazione aggiornato per riflettere la nuova versione

---

## FASE 3: Aggiornamento Complesso del Compilatore (`compilatore.py`)

Questa è stata la modifica più impegnativa della sessione, richiedendo l'implementazione di regex complesse e logica di parsing sofisticata.

1.  **Nuove Regex per Condizioni (Priorità Massima):**
    *   [`p_regola_cond_possesso`](compilatore.py:14): Riconosce `Invece di [verbo] [oggetto] se il giocatore ha [oggetto2]: dire "...".`
    *   [`p_regola_cond_proprieta`](compilatore.py:20): Riconosce `Invece di [verbo] [oggetto] se [oggetto2] è [proprietà]: dire "...".`

2.  **Logica di Parsing Condizionale (righe 52-80):**
    *   **Condizione di Possesso:** Crea un oggetto `CondizionePossesso` con l'ID dell'oggetto richiesto
    *   **Condizione di Proprietà:** Crea un oggetto `CondizioneProprieta` con ID oggetto e proprietà
    *   Entrambe le condizioni vengono associate alla regola durante la creazione

3.  **Gestione Priorità:**
    *   Le regole condizionali hanno priorità massima nel parsing
    *   Questo garantisce che vengano riconosciute prima delle regole semplici
    *   Ordine di priorità aggiornato:
        1. Regole condizionali (v0.8)
        2. Connessioni tra stanze (v0.7)
        3. Regole semplici (v0.4)
        4. Descrizioni, posizionamenti, definizioni

4.  **Supporto Esteso per Posizionamento:**
    *   Aggiunto supporto per preposizioni `sul`, `sulla`, `sullo`, `sui`, `sugli`, `sulle` nella regex [`p_oggetto_in_stanza`](compilatore.py:35)
    *   Maggiore flessibilità nella scrittura delle storie

---

## FASE 4: Espansione della Libreria Azioni (`libreria_azioni.py`)

1.  **Nuova Azione: `usare`:**
    *   Implementata [`usare_con_logica_default`](libreria_azioni.py:93) per azioni a due oggetti
    *   Alias supportati: `usa`, `usare`, `apri`, `aprire`
    *   Logica di default: messaggio generico "Non sembra avere alcun effetto."
    *   Preparazione per future implementazioni di interazioni complesse

2.  **Aggiornamento LIBRERIA_AZIONI:**
    *   Aggiunta l'azione `usare` al dizionario delle azioni standard
    *   Integrazione completa con il sistema di alias esistente

---

## FASE 5: Rifattorizzazione del Motore di Gioco (`gioco.py`)

Il cuore del game loop è stato potenziato con un **motore di valutazione delle condizioni**.

1.  **Nuovo Flusso di Controllo delle Regole (righe 121-140):**
    ```python
    # Per ogni regola che corrisponde a verbo e oggetto:
    if regola.condizione:
        # Se c'è una condizione, VALUTALA
        if regola.condizione.valuta(mondo):
            # Applica la regola solo se la condizione è vera
            print(regola.risposta)
            regola_applicata = True
            break
    else:
        # Se non c'è condizione, applica sempre la regola
        print(regola.risposta)
        regola_applicata = True
        break
    ```

2.  **Comportamento Intelligente:**
    *   Le regole vengono valutate in ordine di definizione
    *   La prima regola con condizione soddisfatta viene applicata
    *   Le regole senza condizione fungono da "fallback"
    *   Questo permette di creare catene logiche complesse

3.  **Aggiornamento Versione:**
    *   Motore di gioco aggiornato alla v0.9
    *   Commenti aggiornati per riflettere le nuove capacità

---

## FASE 6: File di Test `storia.fav` v0.9

Creato un nuovo scenario di test che dimostra le capacità condizionali:

**Scenario: La Prigione**
- Una cella con una porta di ferro chiusa
- Una chiave arrugginita prendibile
- Tre regole che interagiscono:
  1. Regola base: tentare di aprire la porta → "È chiusa a chiave."
  2. Regola condizionale (possesso): aprire la porta SE hai la chiave → "La porta si apre!"
  3. Regola condizionale (proprietà): esaminare la porta SE è chiusa → descrizione dettagliata

**Meccanica del Puzzle:**
1. Il giocatore esamina la porta → scopre che serve una chiave
2. Il giocatore trova e prende la chiave
3. Il giocatore apre la porta con la chiave → successo!

---

## FASE 7: Test e Verifica

**Test eseguiti con successo:**
1. ✅ Compilazione corretta (1 stanza, 2 oggetti, 3 regole)
2. ✅ Riconoscimento delle regole condizionali
3. ✅ Creazione corretta degli oggetti `Condizione`
4. ✅ Valutazione delle condizioni durante il gameplay
5. ✅ Comportamento corretto delle regole fallback

**Comportamento Verificato:**
- Senza la chiave: "È chiusa a chiave."
- Con la chiave: "La porta si apre!"
- Esame condizionale funzionante
- Proprietà degli oggetti correttamente valutate

---

## RISULTATO FINALE

Con la versione 0.0.9, FAVELLA 1 ha compiuto un salto evolutivo fondamentale. Il motore ora possiede:

✅ **Logica Condizionale:** Regole che si attivano solo in circostanze specifiche  
✅ **Sistema di Puzzle:** Meccaniche chiave-serratura e puzzle basati sullo stato  
✅ **Valutazione Dinamica:** Il mondo reagisce in base all'inventario e alle proprietà degli oggetti  
✅ **Architettura Estensibile:** Gerarchia di condizioni pronta per nuovi tipi  
✅ **Retrocompatibilità:** Tutte le funzionalità precedenti continuano a funzionare  

### Capacità del Motore v0.9:

**Narrativa Interattiva Completa:**
- Mondo esplorabile con multiple location
- Sistema di inventario funzionale
- Oggetti con proprietà dinamiche
- Regole condizionali per puzzle complessi
- Azioni standard con logiche personalizzabili

**Possibilità Creative:**
- Puzzle basati sul possesso di oggetti
- Puzzle basati sullo stato del mondo
- Catene logiche complesse
- Interazioni contestuali
- Narrativa ramificata basata sulle scelte

FAVELLA 1 è ora un motore di Interactive Fiction maturo, capace di supportare avventure testuali complesse con puzzle sofisticati e narrativa dinamica. L'architettura modulare e la gerarchia delle condizioni rendono semplice l'aggiunta di nuovi tipi di logica condizionale in futuro.

---

## PROSSIMI PASSI SUGGERITI

Per la v0.1.0, si potrebbero considerare:
- Azioni a due oggetti complete (`usa X con Y`)
- Condizioni composte (AND, OR, NOT)
- Modifiche dinamiche delle proprietà degli oggetti
- Sistema di eventi temporali
- Contenitori e oggetti annidati